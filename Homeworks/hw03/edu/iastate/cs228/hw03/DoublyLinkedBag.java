package edu.iastate.cs228.hw03;/** * A class of bags whose entries are stored in a chain of doubly linked nodes. *  * @Josh_Loftus *  */public class DoublyLinkedBag<T> implements BagInterface<T>	{	private DoublyLinkedNode firstNode; // Reference to first node	private int numberOfEntries;				public DoublyLinkedBag()		{		firstNode = new DoublyLinkedNode(null);		} // end default constructor							public boolean add(T newEntry)		{		DoublyLinkedNode newNode = new DoublyLinkedNode(newEntry);		newNode.next = firstNode;		newNode.prev = null;		if (firstNode != null)			{			firstNode.prev = newNode;			}		firstNode = newNode;		numberOfEntries++;				return true;		} // end add							public T[] toArray()		{		DoublyLinkedNode current = firstNode;		T[] DLN = (T[]) new Object[numberOfEntries];		int index = numberOfEntries - 1;		while (index >= 0 && current != null)			{			DLN[index] = current.data;			current = current.next;			index--;			}		return DLN;		} // end toArray							public boolean isEmpty()		{		if (numberOfEntries == 0)			{			return true;			}		return false;		} // end isEmpty							public int getCurrentSize()		{		return numberOfEntries;		} // end getCurrentSize							public int getFrequencyOf(T anEntry)		{		DoublyLinkedNode current = firstNode;		int numberOfOccurences = 0;		int count = 0;		while (count < numberOfEntries)			{			if (current.data.equals(anEntry))				{				numberOfOccurences++;				}			current = current.next;			count++;			}		return numberOfOccurences;		} // end getFrequencyOf							public boolean contains(T anEntry)		{		DoublyLinkedNode current = firstNode;		while (current.next != null)			{			if (current.data.equals(anEntry))				{				return true;				}			current = current.next;			}		return false;		} // end contains							public void clear()		{		while (!isEmpty())			remove();		} // end clear							public T remove()		{		T result = null;		if (firstNode != null && numberOfEntries > 0)			{			result = firstNode.data;			firstNode = firstNode.next; // Remove first node from chain			numberOfEntries--;			} // end if					return result;		} // end remove							public boolean remove(T anEntry)		{		boolean result = false;		DoublyLinkedNode nodeN = getReferenceTo(anEntry);				if (nodeN != null)			{			nodeN.data = firstNode.data; // Replace located entry with entry in first node						firstNode = firstNode.next; // Remove first node			numberOfEntries--;						result = true;			} // end if					return result;		} // end remove							public T replace(T replacement)		{		T removed = null;		if (!this.isEmpty())			{			removed = this.remove();			this.add(replacement);			}		return removed;		}							public void removeEvery(T anEntry)		{		DoublyLinkedNode node = this.firstNode;		while (node.next != null)			{			DoublyLinkedNode newNode = new DoublyLinkedNode(node.data);			T current = newNode.data;			if (current.equals(anEntry))				{				remove(current);				}			node = node.next;			}		}							/**	 * Override the equals method of Object class so that it returns true when the	 * contents of two DoublyLinkedBags are same. Note that two equal	 * DoublyLinkedBags contain the same number of entries, and each entry occurs in	 * each DoublyLinkedBag the same number of times. I.e., the elements in two do	 * not need to be in exact same location.	 * 	 * Before checking the contents inside this method make sure that the passed in	 * object is not null, is of the same runtime class, and the lengths are same.	 * If any of these fail you can return false. Otherwise, you base your return	 * results on contents. (At the start you can also do the quick check if both	 * refer to the same object in memory.)	 */	@Override	public boolean equals(Object obj)		{		if (this == null || obj == null)			{			return false;			}		if (this.getClass() != obj.getClass())			{			return false;			}		DoublyLinkedBag<T> other = (DoublyLinkedBag<T>) obj;		DoublyLinkedNode node = this.firstNode;		if (this.getCurrentSize() != other.getCurrentSize())			{			return false;			}		while (node != null)			{			DoublyLinkedNode newNode = new DoublyLinkedNode(node.data);			T current = newNode.data;			if (this.getFrequencyOf(current) != other.getFrequencyOf(current))				{				return false;				}			node = node.next;			}		return true;		}							private DoublyLinkedNode getReferenceTo(T anEntry)		{		boolean found = false;		DoublyLinkedNode currentNode = firstNode;				while (!found && (currentNode != null))			{			if (anEntry.equals(currentNode.data))				found = true;			else				currentNode = currentNode.next;			} // end while					return currentNode;		} // end getReferenceTo							/**	 * Returns String representation of the items in this bag. For example, it would	 * return [A, B, C] if bag had three Strings "A", "B", and "C".	 * 	 * @return String representation of items in this bag enclosed in square	 *         brackets, separated by comma and a single space (see example above).	 *         You can rely on the fact that items' proper toString method was	 *         implemented. In this method ONLY if you need to you can use String	 *         class's methods. Also, ONLY in this method you can use fully	 *         qualified name for StringBuffer class, and use all of its methods.	 */	@Override	public String toString()		{		String list = "";		String firstBracket = "[";		String lastBracket = "]";		DoublyLinkedNode current = firstNode;		int numberRemaining = numberOfEntries;		while (current != null && numberRemaining > 0)			{			if (isEmpty())				{				return firstBracket + lastBracket;				}			if (numberRemaining == 1)				{				list = list + current.data;				return firstBracket + list + lastBracket;				}			else				{				list = list + current.data + ", ";				numberRemaining--;				current = current.next;				}			}		String result = firstBracket + list + lastBracket;		return result; // this is returned in case bag is empty.		}			// A class of nodes for a chain of doubly linked nodes.	private class DoublyLinkedNode		{		private T data; // Entry in bag		private DoublyLinkedNode next; // Link to next node		private DoublyLinkedNode prev; // Link to previous node								private DoublyLinkedNode(T dataPortion)			{			this(dataPortion, null, null);			} // end constructor											private DoublyLinkedNode(T dataPortion, DoublyLinkedNode nextNode, DoublyLinkedNode previousNode)			{			data = dataPortion;			next = nextNode;			prev = previousNode;			} // end constructor					} // end DoublyLinkedNode			} // end DoublyLinkedBag