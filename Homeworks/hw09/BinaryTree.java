package edu.iastate.cs228.hw09;import java.util.Iterator;import java.util.NoSuchElementException;import java.util.Stack;import java.util.LinkedList;/** *  * A class that implements the ADT binary tree. *     *  */public class BinaryTree<T> implements BinaryTreeInterface<T>{  private BinaryNode<T> root;  public BinaryTree()  {	root = null;  } // end default constructor  public BinaryTree(T rootData)  {	root = new BinaryNode<>(rootData);  } // end constructor  public BinaryTree(T rootData, BinaryTree<T> leftTree, BinaryTree<T> rightTree)  {	privateSetTree(rootData, leftTree, rightTree);  } // end constructor  public void setTree(T rootData)  {	root = new BinaryNode<>(rootData);  } // end setTree  public void setTree(T rootData, BinaryTreeInterface<T> leftTree, BinaryTreeInterface<T> rightTree)  {	privateSetTree(rootData, (BinaryTree<T>) leftTree, (BinaryTree<T>) rightTree);  } // end setTree  private void privateSetTree(T rootData, BinaryTree<T> leftTree, BinaryTree<T> rightTree)  {	root = new BinaryNode<>(rootData);	if ((leftTree != null) && !leftTree.isEmpty())	  root.setLeftChild(leftTree.root);	if ((rightTree != null) && !rightTree.isEmpty())	{	  if (rightTree != leftTree)		root.setRightChild(rightTree.root);	  else		root.setRightChild(rightTree.root.copy());	} // end if	if ((leftTree != null) && (leftTree != this))	  leftTree.clear();	if ((rightTree != null) && (rightTree != this))	  rightTree.clear();  } // end privateSetTree  public T getRootData()  {	if (isEmpty())	  throw new EmptyTreeException();	else	  return root.getData();  } // end getRootData  public boolean isEmpty()  {	return root == null;  } // end isEmpty  public void clear()  {	root = null;  } // end clear  public void setRootData(T rootData)  {	root.setData(rootData);  } // end setRootData  public void setRootNode(BinaryNode<T> rootNode)  {	root = rootNode;  } // end setRootNode  public BinaryNode<T> getRootNode()  {	return root;  } // end getRootNode  public int getHeight()  {	return root.getHeight();  } // end getHeight  public int getNumberOfNodes()  {	return root.getNumberOfNodes();  } // end getNumberOfNodes  public Iterator<T> getPreorderIterator()  {	return new PreorderIterator();  } // end getPreorderIterator  public Iterator<T> getInorderIterator()  {	return new InorderIterator();  } // end getInorderIterator  public Iterator<T> getPostorderIterator()  {	return new PostorderIterator();  } // end getPostorderIterator  public Iterator<T> getLevelOrderIterator()  {	return new LevelOrderIterator();  } // end getLevelOrderIterator    private class InorderIterator implements Iterator<T>  {	private Stack<BinaryNode<T>> nodeStack;	private BinaryNode<T> currentNode;	public InorderIterator()	{	  nodeStack = new Stack<>();	  currentNode = root;	} // end default constructor	public boolean hasNext()	{	  return !nodeStack.empty() || (currentNode != null);	} // end hasNext	public T next()	{	  BinaryNode<T> nextNode = null;	  while (currentNode != null)	  {		nodeStack.push(currentNode);		currentNode = currentNode.getLeftChild();	  }	  if (!nodeStack.empty())	  {		nextNode = nodeStack.pop();		assert nextNode != null;		currentNode = nextNode.getRightChild();	  } 	  else throw new NoSuchElementException();	  return nextNode.getData();	}	  } // end InorderIterator  public void iterativeInorderTraverse()  {	Stack<BinaryNode<T>> nodeStack = new Stack<>();	BinaryNode<T> currentNode = root;	while (!nodeStack.isEmpty() || (currentNode != null))	{	  while (currentNode != null)	  {		nodeStack.push(currentNode);		currentNode = currentNode.getLeftChild();	  }	  if (!nodeStack.isEmpty())	  {		BinaryNode<T> nextNode = nodeStack.pop();		assert nextNode != null;		System.out.print(nextNode.getData() + " ");		currentNode = nextNode.getRightChild();	  }	}  } // end iterativeInorderTraverse      /**   * Outputs exact same info as iterativeInorderTraverse()   * method but for preorder traversal. You need to use Stack    * to implement this method iteratively.     */  public void iterativePreorderTraverse()  {	//TODO	return;  }  /**   * Outputs exact same info as iterativeInorderTraverse()   * method but for postorder traversal. You need to use    * Stack to implement this method iteratively.    */  public void iterativePostorderTraverse()  {	//TODO	return;  }  /**   * Outputs exact same info as iterativeInorderTraverse()   * method but for levelorder traversal. You need to use    * Queue to implement this method iteratively. Simulate    * Queue using LinkedList.   *     */  public void iterativeLevelorderTraverse()  {	//TODO	return;  }    private class PreorderIterator implements Iterator<T>  {	//You are allowed to create no more than	//2 data fields in this class.		public PreorderIterator()	{	  //TODO	}	public boolean hasNext()	{	  //TODO	  return false;	}	public T next()	{	  //TODO	  return null;	}  } // end PreorderIterator  private class PostorderIterator implements Iterator<T>  {	//You are allowed to create no more than	//2 data fields in this class.	public PostorderIterator()	{	 //TODO	}	public boolean hasNext()	{	 //TODO	 return false;	}	public T next()	{	 //TODO	 return null;	}  } // end PostorderIterator  private class LevelOrderIterator implements Iterator<T>  {	//You are allowed to create no more than	//2 data fields in this class.	public LevelOrderIterator()	{	 //TODO	}	public boolean hasNext()	{	 //TODO	 return false; 	}	public T next()	{	 //TODO 	 return null;	}  } // end LevelOrderIterator} // end BinaryTree